# WOLips

Went over the WOLips features a little, and here are some thoughts. I am explicitly not mentioning anything EOF related, D2W related, Ant build related etc. Everything old style and off-basics is off the menu. I'll probably address those later though, for explaining _why_ I consider them "off the menu".

Some of the stuff I _do_ mention is still stuff I don't think needs to be present, but I decided to address because some people might think it _needs_ to be present. An example of that are the WO-specific launch configurations, i.e. a separate method to run WO applications.

So, what WOlips really does is:


## 1. Creates a build during development

WOLips does one thing that *might* be required. Whether it's *actually* required requires some investigation.

As I mentioned yesterday, WOLips maintains a "fake bundle" in a "build" folder for the app to use during development to locate resources. The folder contains Info.plist (some configuration for WO), resources (bundle resources and component templates) and webserver resources. This "fake bundle" is set as the working directory for the running Java application.

I thought this was redundant by now and merely an artifact from the Ant days, but had forgotten that I always mindlessly point WO to this directory as a working directory since my WO Apps throw an error on launch without it. This morning, I decided to investigate the error, and turns out it's not in WO but Project Wonder - and disabling the failing logic there actually results in an apparently fine WO app running with seemingly nothing missing and locating resources from the project itself. So - I think that with a fix in Wonder, the "build" could become unneccessary. I just haven't looked into if and how that fix can be done.

If fixing this in Wonder turns out not to be a workable solution, I don't think it's hard to recreate WOLips's build, especially if focusing on a single project type, i.e. a simple maven WO app without any of the "additional frameworks". The instructions and configuration for how that "build" come from pattern files in a WO project's "woproject" folder. These files instruct WOLips and the WO maven plugin on what files to put where and which files to ignore when assembling a build product; files matching a certain pattern are resources, another one's a component template, these are webserver resources etc.).

This is still a hassle though (and an unneccessary one IMHO) so a Wonder fix would be vastly preferable. ERXLoader, where the error occurs on startup in Project Wonder if the build folder is missing, is a terrible mess anyway, and I've deleted most of it in the Wonder fork I use for everything. Deleting even more would be nice.

I'm probably going to investigate this further - and I'm switching to running my apps with the project itself as the working directory for now instead of the build folder (with the failing logic in ERXLoader/Wonder disabled) and see if I spot any potential problems.


## 2. Creation of WO-specific files

WOLips provides quite a few templates for the creation of new files, projects etc. For a modern WO maven app that doesn't use EOF or D2W, I think the only one that matters is "WOComponent", which creates a new WOComponent subclass and the associated template files. Easy enough.

WOLips also creates the .api files used to specify the binding API of elements and components. This isn't provided as a specific "new file" template though, but automatically generated by the component template editor when you start fidgeting with a component's API. Including an API template might be nice though, since to my knowledge WOLips does't have a good way to create an API file for a non-component dynamic element. Not many people relly do that though and creating an API file by hand is easy, so I  should probably relax a little. I'm discussing new features and gold plating here :).


## 3. The WOLips server

I didn't mention this yesterday, since I don't think many people use it. I use it though and recently fixed it up in WOLips to keep it working.

This is really just a simple HTTP server that runs inside Eclipse, allowing you to invoke actions in Eclipse through URLs in some locations in an application's dev UI. The most common one is probably clicking a stack trace element on an exception page, which opens the corresponding Java file and navigates to the clicked line. Bears mentioning since it's actually quite useful/convenient and probably simple to implement in any IDE.


## 4. Creation of WO-specific "Launch configurations"

Probably mostly redundant today. This was useful since it took care of generating a classpath, which was especially convenient for Ant projects. It's a little nice since it has a separate UI for setting WO-specific properties, and you can change the default properties for new applications. But if you're always running the same applications (which I think most current WO developers do) that becomes less important.

I haven't used this functionality in years (stopped using it since it can generate a broken classpath for maven projects). I prefer to start my WO applications as plain Java applications, passing any arguments via program arguments/VM Arguments. So; might be a "nice to have" but not a neccessity.


## 5. The component template editor / Element API editor

Now, this is the real doozy

1. It knows that folders ending with ".wo" are "packages" that are essentially treated as single files when working with them. Double clicking a ".wo" folder will open a split editor with the .html at the top and the .wod at the bottom. Regarding this, not many people know that WO actually supports _not_ having a .wo folder, but you can also just have a single HTML-file as your component template, using inline tags for any dynamic elements. I vastly prefer this style, since I never write use .wod files - but this is still rarely used since WOLips doesn't really support single file templates.

* Parsing WO templates, validation etc.
* Autocompletion for element names (WOElement subclasses on the classpath), binding names (by parsing the .api XML files), valid keypaths for bindings (public fields and methods, matching the KVC conventions - or fixed values from the API) etc.
* More stuff to come...